import numpy as np
from copy import deepcopy
from scipy.stats import multivariate_normal, invgamma, invwishart, norm, bernoulli
import pdb

# define hyper-parameters
P = 104
K = 2
R = 50
n1 = 150
n2 = 50

# generate data
mu01 = [0.8] * 4
mu02 = [-0.8] * 4
B1 = np.ones((2, 4)) * 0.8
B2 = np.ones((2, 4)) * 0.8
Sigma1 = np.ones((4, 4)) * 0.5
Sigma1 += np.diag(np.ones(4) * 0.5)
Sigma2 = deepcopy(Sigma1)
noise = multivariate_normal(np.zeros(100), np.ones((100, 100)) * 0.1 + np.diag(np.ones(100) * 0.9))

# bayesian reference
a0 = 3
ak = [3] * K
b0 = 0.1
bk = [0.1] * K
b0k = [0] * K
dk = [P + 3] * K
Q = 0.1 * np.diag(np.ones(P))
m_0k = [0] * K
h = 4
h1 = 1
e = -3
f = 0
wrk = np.array([np.ones(50) * 0.05] * K)


class MCMC_sampler:
    def __init__(self, X, Z, g):
        self.X = X  # N * P
        self.Z = Z  # N * R
        self.g = g  # N * 1
        self.gamma = bernoulli(0.05).rvs(P)  # P * 1
        self.delta = []
        for k in range(2):
            self.delta.append(np.apply_along_axis(lambda x: bernoulli(x).rvs(R), 0, wrk[k, :]))
        self.delta = np.array(self.delta)  # R * K
        self.m_0k = m_0k

    def one_epoch(self):
        self.sigma2 = np.apply_along_axis(
            lambda ab: invgamma(ab[0], ab[1]).rvs(P),
            0, [[a0] + ak, [b0] + bk]
        ).squeeze()  # P * (K+1)

        self.beta = []
        self.Gamma_0 = []
        self.nu = []
        self.mu_0 = []
        for k in range(2):
            sigma2_k = self.sigma2[:, k + 1]  # P

            self.beta.append(np.apply_along_axis(lambda sigma: norm(b0k[k], sigma).rvs(R), 0, [sigma2_k]))
            Gamma_0k = invwishart(dk[k], Q).rvs(1)  # P * P
            self.Gamma_0.append(Gamma_0k)

            m_0k = np.ones(P) * self.m_0k[k]
            nu_k = multivariate_normal(m_0k, h1 * Gamma_0k).rvs(1).squeeze()  # P
            self.nu.append(nu_k)
            self.mu_0.append(multivariate_normal(nu_k, Gamma_0k).rvs(1))  # P

        self.beta = np.array(self.beta)  # K * R * P
        self.Gamma_0 = np.array(self.Gamma_0)  # K * P * P
        self.nu = np.array(self.nu)  # K * P
        self.mu_0 = np.array(self.mu_0)  # K * P
        pdb.set_trace()

    def M_H_gamma(self, gamma_O):
        def mu_ik_gamma(mu_0k_gamma):
            return mu_0k_gamma + np.matmul(self.beta[self.delta == 1].T, self.Z[self.delta == 1])  # P_gamma

        def p_xj_gamma_c(gamma):
            Omega_gamma_c = np.diag(self.sigma2[:, 0][gamma == 0])  # (P - P_gamma) * (P - P_gamma)
            x_gamma_c = self.X[:, gamma == 0]  # N * P_gamma
            return np.sum(np.log(
                np.apply_along_axis(
                    lambda x: multivariate_normal.pdf(x, np.zeros_like(x), Omega_gamma_c),
                    0, x_gamma_c
                )
            ))

        def p_xj_gamma(gamma):
            x_gamma = self.X[:, gamma == 1]

            def calc_p_k(k):
                Sigma_gamma = np.diag(self.sigma2[gamma == 1, k + 1])  # P_gamma * P_gamma
                return np.sum(np.log(
                    np.apply_along_axis(
                        lambda x: multivariate_normal.pdf(x, mu_ik_gamma(self.mu_0[k, gamma == 1]), Sigma_gamma),
                        1, x_gamma[self.g == k]
                    )
                ))

            return calc_p_k(0) + calc_p_k(1)

        def p_mu_0kgamma(gamma):
            def calc_p_k(k):
                return np.log(multivariate_normal.pdf(self.mu_0[k, gamma == 1],
                                                      self.nu[gamma == 1, k],
                                                      h1 * self.Gamma_0[:, :, k]))
            return calc_p_k(0) + calc_p_k(1)

        def p_mu_0kgamma_c(gamma):
            pass

        def p_gamma(gamma):
            return p_xj_gamma_c(gamma) + p_xj_gamma(gamma) + p_mu_0kgamma(gamma) + \
                   p_mu_0kgamma_c(gamma) + np.sum(np.log(np.apply_along_axis(bernoulli(0.05).pmf, 0, gamma)))

        ratio = p_gamma(self.gamma) - p_gamma(gamma_O)
        if ratio >= 0:
            return self.gamma
        elif np.random.uniform() < ratio:
            return self.gamma
        else:
            return gamma_O


if __name__ == "__main__":
    # generate data samples
    Z = multivariate_normal(np.zeros(R), np.diag(np.ones(R))).rvs(n1 + n2)  #
    noises = noise.rvs(n1 + n2)
    x1 = np.zeros((n1, P))
    x2 = np.zeros((n2, P))

    for i in range(n1):
        x1[i, :4] = multivariate_normal(mu01 + np.matmul(np.transpose(B1), Z[i, :2]), Sigma1).rvs(1)
        x1[i, 4:] = noises[i, :]

    for i in range(n2):
        x2[i, :4] = multivariate_normal(mu02 + np.matmul(np.transpose(B2), Z[i, :2]), Sigma2).rvs(1)
        x2[i, 4:] = noises[i, :]

    X = np.vstack((x1, x2))
    g = np.concatenate((np.zeros(n1), np.ones(n2)))

    # begin simulation
    agent = MCMC_sampler(X, Z, g)
    agent.one_epoch()
